#include <iostream>  // Підключення бібліотеки для введення/виведення
#include <fstream>   // Підключення бібліотеки для роботи з файлами
#include <string>    // Підключення бібліотеки для роботи зі строками
#include <cstring>   // Підключення бібліотеки для роботи з C-строками
#include <cctype>    // Підключення бібліотеки для роботи з перевірками символів

using namespace std;  // Використання стандартного простору імен

// ============= Завдання 1 (Варіант 18) =============
// Реалізація свого методу заміни частини рядка
void my_replace(char* str, size_t pos, size_t len, const char* repl) {
    size_t i = 0;  // Індекс для проходу по рядку заміни
    // Процес заміни символів з repl у рядок str
    while (repl[i] != '\0' && i < len && pos + i < strlen(str)) {
        str[pos + i] = repl[i];  // Заміняємо символи
        i++;  // Переходимо до наступного символа
    }
}

// ============= Завдання 2 (Варіант 41) =============
// Підрахунок слів у рядку (тільки кирилиця, як в умові)
int count_words(const string& str) {
    int count = 0;  // Лічильник слів
    bool in_word = false;  // Флаг для перевірки, чи ми в середині слова

    // Перебір всіх символів рядка
    for (char ch : str) {
        if (ch != ' ') {  // Якщо символ не пробіл
            if (!in_word) {  // Якщо ми не в середині слова
                in_word = true;  // Починаємо нове слово
                count++;  // Збільшуємо лічильник слів
            }
        } else {
            in_word = false;  // Якщо пробіл, вийшли з слова
        }
    }

    return count;  // Повертаємо кількість слів
}

// Перевірка рядка на наявність лише допустимих символів
bool is_valid(const string& str) {
    for (char ch : str) {  // Перебір всіх символів рядка
        // Перевіряємо, чи символ є літерою, цифрою, пробілом або підкресленням
        if (!(isalpha((unsigned char)ch) || isdigit((unsigned char)ch) || ch == ' ' || ch == '_'))
            return false;  // Якщо є недопустимі символи, повертаємо false
    }
    return true;  // Якщо всі символи допустимі, повертаємо true
}

// Створення текстового файлу з 10 рядками (вбудований файл)
void create_sample_file() {
    ofstream file("sample.txt");  // Відкриваємо файл для запису
    if (!file) {  // Перевірка на успішне відкриття файлу
        cerr << "Не вдалося відкрити файл для запису!" << endl;  // Повідомлення про помилку
        return;
    }
    // Записуємо 10 тестових рядків у файл
    file << "привіт світ" << endl;
    file << "я люблю програмування" << endl;
    file << "це тестовий рядок" << endl;
    file << "штучний інтелект змінює світ" << endl;
    file << "це п’ята стрічка" << endl;
    file << "ми вивчаємо C++" << endl;
    file << "КХАІ найкращий" << endl;
    file << "лабораторна робота" << endl;
    file << "треба рахувати слова" << endl;
    file << "остання стрічка" << endl;
    file.close();  // Закриваємо файл
}

// Обробка текстового файлу рядок за рядком
void process_file() {
    ifstream file("sample.txt");  // Відкриваємо файл для читання
    if (!file) {  // Перевірка на успішне відкриття файлу
        cerr << "Не вдалося відкрити файл для читання!" << endl;  // Повідомлення про помилку
        return;
    }

    ofstream out("output.txt");  // Відкриваємо файл для запису результатів
    if (!out) {  // Перевірка на успішне відкриття файлу
        cerr << "Не вдалося відкрити файл для запису!" << endl;  // Повідомлення про помилку
        return;
    }

    string line;  // Змінна для збереження рядка з файлу
    while (getline(file, line)) {  // Читання файлу по рядках
        if (is_valid(line)) {  // Якщо рядок допустимий
            int count = count_words(line);  // Підраховуємо кількість слів
            out << "Рядок: \"" << line << "\" має " << count << " слів." << endl;  // Записуємо результат у файл
        } else {
            out << "Рядок \"" << line << "\" недопустимий." << endl;  // Якщо рядок недопустимий
        }
    }

    file.close();  // Закриваємо файл для читання
    out.close();   // Закриваємо файл для запису
}

// Головна функція
int main() {
    create_sample_file();  // створюємо sample.txt одразу

    int choice;  // Змінна для вибору користувача
    do {
        // Виведення меню
        cout << "\n1. Замінити частину рядка (my_replace і string::replace)\n";
        cout << "2. Порахувати кількість слів у введеному рядку\n";
        cout << "3. Обробити файл (sample.txt) і зберегти у output.txt\n";
        cout << "0. Вийти\n";
        cout << "Ваш вибір: ";
        cin >> choice;  // Введення вибору користувача
        cin.ignore();  // Очищаємо буфер для getline

        switch (choice) {
            case 1: {
                string str;  // Змінна для введеного рядка
                cout << "Введіть рядок: ";
                getline(cin, str);  // Введення рядка

                char c_str[256];  // Масив для копії C-строки
                strncpy(c_str, str.c_str(), sizeof(c_str));  // Копіюємо рядок в C-строку
                c_str[sizeof(c_str) - 1] = '\0';  // Завершуємо C-строку

                size_t pos, len;  // Позиція і довжина заміни
                string repl;  // Рядок для вставки
                cout << "Введіть позицію для заміни: ";
                cin >> pos;
                cout << "Введіть довжину для заміни: ";
                cin >> len;
                cin.ignore();  // Очищаємо буфер перед введенням нового рядка
                cout << "Введіть рядок для вставки: ";
                getline(cin, repl);

                // стандартний метод string::replace
                string str_copy = str;  // Копія введеного рядка
                if (pos <= str_copy.length())  // Якщо позиція в межах рядка
                    str_copy.replace(pos, len, repl);  // Замінюємо частину рядка
                cout << "Результат string::replace: " << str_copy << endl;

                // Власна реалізація заміни
                my_replace(c_str, pos, len, repl.c_str());  // Викликаємо my_replace
                cout << "Результат my_replace: " << c_str << endl;

                // Запис результату в файл
                ofstream result_file("result_task_1.txt", ios::app);  // Відкриваємо файл для запису результату
                if (result_file) {
                    result_file << "Рядок: " << str << "\nРезультат заміни: " << c_str << endl;
                    result_file.close();  // Закриваємо файл
                } else {
                    cerr << "Не вдалося відкрити файл для запису результатів!" << endl;  // Повідомлення про помилку
                }

                break;
            }

            case 2: {
                string line;  // Змінна для введеного рядка
                cout << "Введіть рядок для підрахунку слів: ";
                getline(cin, line);  // Введення рядка

                int count = count_words(line);  // Підраховуємо кількість слів
                cout << "Кількість слів: " << count << endl;  // Виводимо результат

                // Запис результату в файл
                ofstream result_file("result_task_2.txt", ios::app);  // Відкриваємо файл для запису
                if (result_file) {
                    result_file << "Рядок: " << line << "\nКількість слів: " << count << endl;
                    result_file.close();  // Закриваємо файл
                } else {
                    cerr << "Не вдалося відкрити файл для запису результатів!" << endl;  // Повідомлення про помилку
                }

                break;
            }

            case 3: {
                process_file();  // Обробка файлу
                cout << "Файл оброблено. Перевірте output.txt." << endl;  // Повідомлення про завершення обробки
                break;
            }

            case 0:
                cout << "Вихід..." << endl;  // Повідомлення про вихід з програми
                break;

            default:
                cout << "Невірний вибір!" << endl;  // Повідомлення про невірний вибір
        }

    } while (choice != 0);  // Програма продовжує працювати, поки не вибрано вихід

    return 0;  // Завершення програми
}
